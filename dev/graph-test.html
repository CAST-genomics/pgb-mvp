<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pangenome Graph Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .output {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        h2 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Pangenome Graph Analysis</h1>
    <p>This page demonstrates the PangenomeGraph class for traversing pangenome data.</p>

    <div class="section">
        <h2>Data Loading</h2>
        <div style="margin-bottom: 15px;">
            <label for="dataUrl">Load from URL:</label>
            <input type="text" id="dataUrl" placeholder="https://example.com/data.json" style="width: 300px; margin-right: 10px;">
            <button onclick="loadFromUrl()">Load URL</button>
        </div>
        <div style="margin-bottom: 15px;">
            <label for="fileInput">Load from file:</label>
            <input type="file" id="fileInput" accept=".json" style="margin-right: 10px;">
            <button onclick="loadFromFile()">Load File</button>
        </div>
        <div style="margin-bottom: 15px;">
            <button onclick="loadDefaultData()">Load Default Data</button>
        </div>
    </div>

    <div class="section">
        <h2>Graph Analysis</h2>
        <button onclick="runBasicAnalysis()">Run Basic Analysis</button>
        <button onclick="runPathAnalysis()">Run Path Analysis</button>
        <button onclick="runAssemblyAnalysis()">Run Structure Analysis</button>
        <button onclick="runSignInterpretation()">Run Sign Interpretation</button>
        <button onclick="runCycleAnalysis()">Run Cycle Analysis</button>
        <button onclick="runAssemblyWalk()">Run Assembly Walk</button>
        <button onclick="clearOutput()">Clear Output</button>
        <div id="output" class="output">Click a button to start analysis...</div>
    </div>
</div>

<script type="module">
    import PangenomeGraph from '../src/pangenomeGraph.js';

    let graph = null;
    let jsonData = null;

    function log(message) {
        const output = document.getElementById('output');
        output.textContent += message + '\n';
        output.scrollTop = output.scrollHeight;
    }

    function clearOutput() {
        document.getElementById('output').textContent = '';
    }

    async function loadDefaultData() {
        try {
            log('Loading default pangenome data...');
            const response = await fetch('/public/version2/chr2-879500-880000.json');
            jsonData = await response.json();
            log('Default data loaded successfully!');
            log(`Loaded ${Object.keys(jsonData.node).length} nodes and ${jsonData.edge ? jsonData.edge.length : 0} edges`);
        } catch (error) {
            log(`Error loading default data: ${error.message}`);
            console.error(error);
        }
    }

    async function loadFromUrl() {
        try {
            const url = document.getElementById('dataUrl').value.trim();
            if (!url) {
                log('Please enter a URL');
                return;
            }

            log(`Loading data from URL: ${url}`);
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            jsonData = await response.json();
            log('Data loaded successfully from URL!');
            log(`Loaded ${Object.keys(jsonData.node).length} nodes and ${jsonData.edge ? jsonData.edge.length : 0} edges`);
        } catch (error) {
            log(`Error loading from URL: ${error.message}`);
            console.error(error);
        }
    }

    function loadFromFile() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];

        if (!file) {
            log('Please select a file');
            return;
        }

        if (!file.name.endsWith('.json')) {
            log('Please select a JSON file');
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                jsonData = JSON.parse(e.target.result);
                log('Data loaded successfully from file!');
                log(`Loaded ${Object.keys(jsonData.node).length} nodes and ${jsonData.edge ? jsonData.edge.length : 0} edges`);
            } catch (error) {
                log(`Error parsing JSON file: ${error.message}`);
                console.error(error);
            }
        };

        reader.onerror = function() {
            log('Error reading file');
        };

        reader.readAsText(file);
    }

    async function runBasicAnalysis() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }

        try {
            log('Building graph...');

            log('Building graph...');
            graph = new PangenomeGraph();
            graph.buildFromJSON(jsonData);



            log('=== Basic Graph Analysis ===');

            const stats = graph.getStatistics();
            log(`Graph Statistics:`);
            log(`  - Nodes: ${stats.nodeCount}`);
            log(`  - Edges: ${stats.edgeCount}`);
            log(`  - Source nodes: ${stats.sourceNodes}`);
            log(`  - Sink nodes: ${stats.sinkNodes}`);
            log(`  - Average out-degree: ${stats.averageOutDegree.toFixed(2)}`);
            log(`  - Average in-degree: ${stats.averageInDegree.toFixed(2)}`);

            const sourceNodes = graph.getSourceNodes();
            const sinkNodes = graph.getSinkNodes();
            log(`\nSource nodes: ${sourceNodes.join(', ')}`);
            log(`Sink nodes: ${sinkNodes.join(', ')}`);

            log('\n=== Node Details ===');
            for (const nodeName of graph.getNodes()) {
                const neighbors = graph.getNeighbors(nodeName);
                const predecessors = graph.getPredecessors(nodeName);
                const nodeSign = graph.getNodeSign(nodeName);

                log(`Node ${nodeName} (${nodeSign}):`);
                log(`  - Outgoing edges: ${neighbors.size}`);
                log(`  - Incoming edges: ${predecessors.size}`);
                if (neighbors.size > 0) {
                    log(`  - Neighbors: ${Array.from(neighbors).join(', ')}`);
                }
                log('');
            }

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    async function runPathAnalysis() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }
        if (!graph) {
            log('Please run basic analysis first to build the graph.');
            return;
        }

        try {
            log('\n=== Path Analysis ===');

            const sourceNodes = graph.getSourceNodes();
            const sinkNodes = graph.getSinkNodes();

            if (sourceNodes.length === 0 || sinkNodes.length === 0) {
                log('No source or sink nodes found for path analysis.');
                return;
            }

            const startNode = sourceNodes[0];
            const endNode = sinkNodes[0];

            log(`Finding paths from ${startNode} to ${endNode}...`);

            // Analyze path complexity first
            log('\n=== Path Complexity Analysis ===');
            const complexity = graph.analyzePathComplexity(startNode, endNode);
            log(`Reachable nodes from start: ${complexity.reachableCount}`);
            log(`Nodes that can reach end: ${complexity.reachingEndCount}`);
            log(`Common nodes (both reachable and reaching): ${complexity.commonCount}`);
            log(`Branching points: ${complexity.branchingCount}`);
            log(`Convergence points: ${complexity.convergenceCount}`);
            log(`Estimated path count: ${complexity.estimatedPathCount}`);

            if (complexity.branchingPoints.length > 0) {
                log('\nBranching points:');
                complexity.branchingPoints.forEach((bp, index) => {
                    log(`  ${bp.node}: ${bp.branches} branches`);
                });
            }

            // Find shortest path
            const shortestPath = graph.findShortestPath(startNode, endNode);
            if (shortestPath) {
                log(`Shortest path: ${shortestPath.join(' -> ')}`);
                log(`Path length: ${shortestPath.length} nodes`);
            } else {
                log('No path found between these nodes.');
            }

            // Find all paths (limited for performance)
            const howmany = 32;
            log(`\nFinding all paths (limited to ${howmany})...`);
            const allPaths = graph.findAllPaths(startNode, endNode, howmany);
            log(`Found ${allPaths.length} paths:`);

            // Check for duplicates
            const pathStrings = allPaths.map(path => path.join('->'));
            const uniquePaths = new Set(pathStrings);
            log(`Unique paths: ${uniquePaths.size} out of ${allPaths.length} total`);

            if (allPaths.length === howmany) {
                log(`WARNING: Found exactly ${howmany} paths - this suggests the limit was reached!`);
                log(`This could indicate:`);
                log(`1. There are actually ${howmany} or more distinct paths`);
                log(`2. There's a bug in the path finding algorithm`);
                log(`3. The graph has cycles creating infinite path possibilities`);
            }

            // Show first few paths
            const pathsToShow = Math.min(10, allPaths.length);
            for (let i = 0; i < pathsToShow; i++) {
                log(`  Path ${i + 1}: ${allPaths[i].join(' -> ')}`);
            }
            if (allPaths.length > pathsToShow) {
                log(`  ... and ${allPaths.length - pathsToShow} more paths`);
            }

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    async function runAssemblyAnalysis() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }
        if (!graph) {
            log('Please run basic analysis first to build the graph.');
            return;
        }

        try {
            log('\n=== Graph Structure Analysis ===');

            const stats = graph.getStatistics();
            const sourceNodes = graph.getSourceNodes();
            const sinkNodes = graph.getSinkNodes();

            log('Graph structure:');
            log(`  - Total nodes: ${stats.nodeCount}`);
            log(`  - Total edges: ${stats.edgeCount}`);
            log(`  - Source nodes: ${sourceNodes.length}`);
            log(`  - Sink nodes: ${sinkNodes.length}`);

            if (sourceNodes.length === 1 && sinkNodes.length === 1) {
                log(`  - This appears to be a single-source, single-sink graph`);
            } else if (sourceNodes.length > 1) {
                log(`  - This is a multi-source graph`);
            } else if (sinkNodes.length > 1) {
                log(`  - This is a multi-sink graph`);
            }

            // Check for cycles
            try {
                graph.topologicalSort();
                log(`  - This is a Directed Acyclic Graph (DAG)`);
            } catch (error) {
                log(`  - This graph contains cycles`);
            }

            // Analyze connectivity patterns
            log('\nConnectivity analysis:');
            const highConnectivityNodes = [];
            for (const nodeName of graph.getNodes()) {
                const outDegree = graph.getNeighbors(nodeName).size;
                const inDegree = graph.getPredecessors(nodeName).size;
                const totalDegree = outDegree + inDegree;

                if (totalDegree > 2) {
                    highConnectivityNodes.push({
                        node: nodeName,
                        outDegree,
                        inDegree,
                        totalDegree
                    });
                }
            }

            if (highConnectivityNodes.length > 0) {
                log('High connectivity nodes:');
                highConnectivityNodes
                    .sort((a, b) => b.totalDegree - a.totalDegree)
                    .forEach(node => {
                        log(`  ${node.node}: out=${node.outDegree}, in=${node.inDegree}, total=${node.totalDegree}`);
                    });
            }

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    async function runSignInterpretation() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }
        if (!graph) {
            log('Please run basic analysis first to build the graph.');
            return;
        }

        try {
            log('\n=== Edge Sign Interpretation ===');

            // Get all edge interpretations
            const interpretations = graph.getAllEdgeInterpretations();

            log('Edge sign interpretations:');
            interpretations.forEach((interpretation, index) => {
                log(`\nEdge ${index + 1}: ${interpretation.edgeId}`);
                log(`  - Starting node: ${interpretation.startingNode} (${interpretation.fromSign})`);
                log(`  - Ending node: ${interpretation.endingNode} (${interpretation.toSign})`);
                log(`  - From connection: ${interpretation.fromConnection}`);
                log(`  - To connection: ${interpretation.toConnection}`);
                log(`  - Interpretation: ${interpretation.interpretation.from}`);
                log(`  - Interpretation: ${interpretation.interpretation.to}`);
            });

            // Show how this affects the adjacency list
            log('\nAdjacency list (graph topology):');
            for (const nodeName of graph.getNodes()) {
                const neighbors = graph.getNeighbors(nodeName);
                const predecessors = graph.getPredecessors(nodeName);

                log(`  ${nodeName}:`);
                if (neighbors.size > 0) {
                    log(`    - Outgoing: ${Array.from(neighbors).join(', ')}`);
                }
                if (predecessors.size > 0) {
                    log(`    - Incoming: ${Array.from(predecessors).join(', ')}`);
                }
            }

            // Analyze edge patterns
            log('\n=== Edge Pattern Analysis ===');
            const signPatterns = new Map();

            for (const [edgeId, edgeData] of graph.getEdges()) {
                const pattern = `${edgeData.fromSign}->${edgeData.toSign}`;
                signPatterns.set(pattern, (signPatterns.get(pattern) || 0) + 1);
            }

            log('Edge sign patterns:');
            for (const [pattern, count] of signPatterns) {
                log(`  ${pattern}: ${count} edges`);
            }

            // Demonstrate spline parameter calculation for geometry
            log('\n=== Spline Parameter Calculation for Geometry ===');
            const sampleEdges = Array.from(graph.getEdges().values()).slice(0, 3);
            sampleEdges.forEach((edge, index) => {
                // Get base node names for spline lookup
                const startNodeName = graph.getNodeNameFromSignedRef(edge.startingNode);
                const endNodeName = graph.getNodeNameFromSignedRef(edge.endingNode);

                // Get spline parameters
                const startParam = graph.getSplineParameter(edge.startingNode, 'starting');
                const endParam = graph.getSplineParameter(edge.endingNode, 'ending');

                log(`\nEdge ${index + 1}: ${edge.startingNode} -> ${edge.endingNode}`);
                log(`  Start node: ${startNodeName} (from ${edge.startingNode})`);
                log(`  End node: ${endNodeName} (from ${edge.endingNode})`);
                log(`  Start parameter: ${startParam} (${startParam === 0 ? 'START' : 'END'} of node ${edge.from})`);
                log(`  End parameter: ${endParam} (${endParam === 0 ? 'START' : 'END'} of node ${edge.to})`);
                log(`  Note: ending_node uses opposite logic - opposite sign → END (1), same sign → START (0)`);
                log(`  Geometry usage:`);
                log(`    startSpline = splines.get("${startNodeName}")`);
                log(`    endSpline = splines.get("${endNodeName}")`);
                log(`    xyzStart = startSpline.getPoint(${startParam})`);
                log(`    xyzEnd = endSpline.getPoint(${endParam})`);

                // Demonstrate the new getActualSignedNodeName method
                const actualStartNode = graph.getActualSignedNodeName(edge.startingNode);
                const actualEndNode = graph.getActualSignedNodeName(edge.endingNode);
                log(`  Actual signed node names for spline lookup:`);
                log(`    startSpline = splines.get("${actualStartNode}")`);
                log(`    endSpline = splines.get("${actualEndNode}")`);

                // Show the difference between the methods
                const baseStartNode = graph.getNodeNameFromSignedRef(edge.startingNode);
                const baseEndNode = graph.getNodeNameFromSignedRef(edge.endingNode);
                log(`  Base node names (for reference):`);
                log(`    startNode base: "${baseStartNode}"`);
                log(`    endNode base: "${baseEndNode}"`);
            });

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    async function runCycleAnalysis() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }
        if (!graph) {
            log('Please run basic analysis first to build the graph.');
            return;
        }

        try {
            log('\n=== Cycle Analysis ===');

            const cycles = graph.detectCycles();
            const sccs = graph.findStronglyConnectedComponents();

            log(`Cycle detection:`);
            log(`  - Has cycles: ${graph.hasCycles()}`);
            log(`  - Number of cycles: ${cycles.length}`);
            log(`  - Strongly connected components: ${sccs.length}`);

            if (cycles.length > 0) {
                log('\nDetected cycles:');
                cycles.forEach((cycle, index) => {
                    log(`  Cycle ${index + 1}: ${cycle.join(' -> ')}`);
                });
            }

            if (sccs.length > 0) {
                log('\nStrongly connected components:');
                sccs.forEach((scc, index) => {
                    if (scc.length > 1) { // Only show non-trivial SCCs
                        log(`  SCC ${index + 1}: ${scc.join(', ')}`);
                    }
                });
            }

            // Analyze cycle properties
            if (cycles.length > 0) {
                log('\nCycle properties:');
                const cycleLengths = cycles.map(cycle => cycle.length - 1); // -1 because cycle includes start node twice
                const avgCycleLength = cycleLengths.reduce((sum, len) => sum + len, 0) / cycleLengths.length;
                const minCycleLength = Math.min(...cycleLengths);
                const maxCycleLength = Math.max(...cycleLengths);

                log(`  - Average cycle length: ${avgCycleLength.toFixed(2)} nodes`);
                log(`  - Shortest cycle: ${minCycleLength} nodes`);
                log(`  - Longest cycle: ${maxCycleLength} nodes`);
            }

            // Update statistics to show cycle information
            const stats = graph.getStatistics();
            log('\nUpdated graph statistics:');
            log(`  - Has cycles: ${stats.hasCycles}`);
            log(`  - Cycle count: ${stats.cycleCount}`);
            log(`  - Strongly connected components: ${stats.stronglyConnectedComponents}`);
            log(`  - Is DAG: ${stats.isDAG}`);

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    async function runAssemblyWalk() {
        if (!jsonData) {
            log('Please load data first using one of the data loading options above.');
            return;
        }
        if (!graph) {
            log('Please run basic analysis first to build the graph.');
            return;
        }

        try {
            log('\n=== Assembly Walk ===');

            const sourceNodes = graph.getSourceNodes();
            const sinkNodes = graph.getSinkNodes();
            log(`Source nodes: ${sourceNodes.join(', ')}`);
            log(`Sink nodes: ${sinkNodes.join(', ')}`);

            const headNode = sourceNodes[0];
            const tailNode = sinkNodes[0];
            log(`Head node: ${headNode}, Tail node: ${tailNode}`);

            // Get all assemblies
            const assemblySet = new Set();
            const nodeAssemblies = new Map();

            log('Processing node assemblies...');
            let nodeCount = 0;
            for (const [nodeName, nodeData] of Object.entries(jsonData.node)) {
                nodeCount++;
                if (nodeCount <= 3) {
                    log(`Node ${nodeName}: ${JSON.stringify(nodeData.assembly)}`);
                }

                // NOTE: August 8 2025 - Version 1 - Multiple Assemblies
                const assemblies = nodeData.assembly.map(({assembly_name}) => assembly_name);

                if (Array.isArray(assemblies)) {
                    assemblies.forEach(assembly => assemblySet.add(assembly));
                    nodeAssemblies.set(nodeName, assemblies);
                } else {
                    assemblySet.add(assemblies);
                    nodeAssemblies.set(nodeName, [assemblies]);
                }
            }

            log(`Total nodes processed: ${nodeCount}`);
            log(`Assemblies: ${Array.from(assemblySet).join(', ')}`);

            // For each assembly, find one path
            for (const assembly of assemblySet) {
                log(`\n${assembly}:`);

                const path = [];
                const visitedNodes = new Set(); // Cycle detection
                let currentNode = headNode;
                const maxPathLength = 1000; // Safety limit

                while (currentNode && currentNode !== tailNode && path.length < maxPathLength) {
                    // Check for cycles
                    if (visitedNodes.has(currentNode)) {
                        log(`  Cycle detected at node ${currentNode}. Breaking.`);
                        break;
                    }

                    visitedNodes.add(currentNode);
                    path.push(currentNode);

                    const neighbors = graph.getNeighbors(currentNode);

                    // Find neighbor that includes this assembly
                    // If multiple neighbors support the assembly, prefer variation nodes
                    let nextNode = null;
                    let variationNode = null;

                    for (const neighbor of neighbors) {
                        const neighborAssemblies = nodeAssemblies.get(neighbor);
                        if (neighborAssemblies && neighborAssemblies.includes(assembly)) {

                            // Dugla rule
                            // We have a node with a single assembly that matches
                            // the assembly we are walking. Follow it. Simple.
                            if (1 === neighborAssemblies.size) {
                                variationNode = neighbor
                            } else {
                                nextNode = neighbor
                            }

                            // NOTE: Legacy rule created by Cursor. The GRCh38 bias could be
                            //       an issue.
                            // Check if this is a variation-only node (doesn't include GRCh38)
                            // if (!neighborAssemblies.includes('GRCh38')) {
                            //     variationNode = neighbor;
                            // } else if (!nextNode) {
                            //     nextNode = neighbor; // Backbone node as fallback
                            // }


                        }
                    }

                    // Prefer variation node if available, otherwise use backbone node
                    currentNode = variationNode || nextNode;
                }

                // Add final node if we reached the tail
                if (currentNode === tailNode) {
                    path.push(tailNode);
                    log(`  Successfully reached tail node`);
                } else if (path.length >= maxPathLength) {
                    log(`  Path length limit reached (${maxPathLength}). Stopping.`);
                } else if (!currentNode) {
                    log(`  Dead end reached. No valid path found.`);
                } else {
                    log(`  Stopped at node ${currentNode} (cycle or no valid neighbors)`);
                }

                log(`  Path length: ${path.length} nodes`);
                if (path.length > 0 && path.length <= 50) {
                    log(`  ${path.join(' -> ')}`);
                } else if (path.length > 50) {
                    log(`  Path too long to display (${path.length} nodes). First 10: ${path.slice(0, 10).join(' -> ')} ... Last 10: ${path.slice(-10).join(' -> ')}`);
                }
            }

        } catch (error) {
            log(`Error: ${error.message}`);
            console.error(error);
        }
    }

    // Make functions globally available
    window.loadDefaultData = loadDefaultData;
    window.loadFromUrl = loadFromUrl;
    window.loadFromFile = loadFromFile;
    window.runBasicAnalysis = runBasicAnalysis;
    window.runPathAnalysis = runPathAnalysis;
    window.runAssemblyAnalysis = runAssemblyAnalysis;
    window.runSignInterpretation = runSignInterpretation;
    window.runCycleAnalysis = runCycleAnalysis;
    window.runAssemblyWalk = runAssemblyWalk;
    window.clearOutput = clearOutput;
</script>
</body>
</html>
